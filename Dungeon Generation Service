-->>: Note: The code here was used in conjunction with the Knit Framework.
-->>: The service still works without Knit, so if you aren't familier with the framework don't worry it is not required!

local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local cloneCompleted = true
local iterationNum = 0
local NumberofRooms
local movingCFrameVal
local currentPart
local CornerTable = {{Count = 0, Name = "Left", Rad = 90}, {Count = 0, Name = "Right", Rad = 0}}
local RotationTable = {0,90,180,270}
local RoomTable = {}

local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit)
local DungeonGenerationService = Knit.CreateService {
	Name = "DungeonGenerationService";
	Client = {};
}

local function GetRandomFront()
	return game.ServerStorage.DungeonParts:FindFirstChild("Front"..Random.new():NextInteger(1,9))
end

local function GetRandomCorner(direction)
	return game.ServerStorage.DungeonParts:FindFirstChild(direction.."Corner"..Random.new():NextInteger(1,3))
end

local function clonePart(part, position, reName)
	cloneCompleted = false
	iterationNum = iterationNum + 1
	if iterationNum == NumberofRooms then
		
		local partName = "Finalboss-Room"
		local newModel = Instance.new('Model', workspace.TargetFilter.Map.DungeonRooms)
		newModel.Name = partName
		for i,v in pairs ( game.ServerStorage.DungeonParts.FinalbossPart:GetChildren()) do
			v:Clone().Parent = newModel
		end
		newModel.PrimaryPart = newModel:FindFirstChild("Floor")
		if string.sub(currentPart.Name, 1, 5) == "Front" then
			newModel:SetPrimaryPartCFrame(currentPart:GetPrimaryPartCFrame() * CFrame.new(0, 0, -movingCFrameVal*1))
		elseif string.sub(currentPart.Name, 1, 10) == "LeftCorner" then
			newModel:SetPrimaryPartCFrame(currentPart:GetPrimaryPartCFrame() * CFrame.new(0, 0, movingCFrameVal*1) * CFrame.fromEulerAnglesXYZ(0,math.rad(180),0))
		elseif string.sub(currentPart.Name, 1, 11) == "RightCorner" then
			newModel:SetPrimaryPartCFrame(currentPart:GetPrimaryPartCFrame() * CFrame.new(-movingCFrameVal*1, 0, 0) * CFrame.fromEulerAnglesXYZ(0,math.rad(90),0))
		end
		currentPart = newModel
		newModel.Floor.Parent = workspace.FloorFilter
	else
		local partName = part.Name
		local newModel = Instance.new('Model', workspace.TargetFilter.Map.DungeonRooms)
		newModel.Name = partName
		for i,v in pairs (part:GetChildren()) do
			v:Clone().Parent = newModel
		end
		if reName ~= nil then
			newModel.Name = reName
			part.Name = reName
		end
		currentPart = newModel
		newModel.PrimaryPart = newModel:FindFirstChild("Floor")
		if position ~= nil then
			newModel:SetPrimaryPartCFrame(position)
		end
		table.insert(RoomTable, newModel)
		CollectionService:AddTag(newModel, "Obstacle")
	end
	cloneCompleted = true
end

local function CornerCheck(tbl1, tbl2, part)
	if CornerTable[tbl1].Count ~= 2 then
		CornerTable[tbl1].Count += 1
		if CornerTable[tbl2].Count > 0 then
			CornerTable[tbl2].Count -= 1
		end
		clonePart(GetRandomCorner(CornerTable[tbl1].Name), part:GetPrimaryPartCFrame() 
			* CFrame.new(0, 0, -movingCFrameVal) * CFrame.fromEulerAnglesXYZ(0, math.rad(CornerTable[tbl1].Rad) ,0))
		return true
	end
end

local function CornerGenerate(part)
	if CornerTable[1].Count ~= 2 and CornerTable[2].Count ~= 2 then
		local CornerChance = math.random(1,2)
		CornerTable[CornerChance].Count += 1
		clonePart(GetRandomCorner(CornerTable[CornerChance].Name), part:GetPrimaryPartCFrame() * 
			CFrame.new(0, 0, -movingCFrameVal) * CFrame.fromEulerAnglesXYZ(0,math.rad(CornerTable[CornerChance].Rad),0))
	else
		if not CornerCheck(1, 2, part) then
			CornerCheck(2, 1, part)
		end
	end	
end

local function checkProceduralPart(part)
	-->>: String.sub checks to see what type of chunk to generate
	if string.sub(part.Name, 1, 5) == "Front" or string.sub(part.Name, 1,3) == "End" then
		local FrontChance = math.random(1,3) -->>: Randomly generates a front chunk, or a right/left corner chunk
		if FrontChance == 1 then
			clonePart(GetRandomFront(), part:GetPrimaryPartCFrame() * CFrame.new(0, 0, -movingCFrameVal))
		else
			CornerGenerate(part)
		end
	elseif string.sub(part.Name, 1, 4) == "Left" then -->>: Left Corner Chunk
		clonePart(GetRandomFront(), part:GetPrimaryPartCFrame() * CFrame.new(0, 0, movingCFrameVal) * CFrame.fromEulerAnglesXYZ(0,math.rad(180),0))
	elseif string.sub(part.Name, 1, 5) == "Right" then -->>: Right Corner Chunk
		clonePart(GetRandomFront(), part:GetPrimaryPartCFrame() * CFrame.new(-movingCFrameVal, 0, 0) * CFrame.fromEulerAnglesXYZ(0,math.rad(90),0))
	end
end

function DungeonGenerationService:Generate(rooms, roomSize, floorSize, cFrame)

	local StartRoom = game.ServerStorage.DungeonParts.StartRoom:Clone()
	StartRoom.Parent = workspace.TargetFilter.Map.StarterRoom
	StartRoom:SetPrimaryPartCFrame(CFrame.new(cFrame) * CFrame.Angles(0, math.rad(RotationTable[math.random(1,4)]), 0)) -->>: Sets startCFrame with a random rotation
	
	NumberofRooms = rooms
	movingCFrameVal = floorSize
	
	local startCFrame = StartRoom.StartCFrame.CFrame
	
	clonePart(GetRandomFront(), startCFrame) -->>: Always starts with a front part

	for i = 1, NumberofRooms, 1 do -->>: Generates the rooms
		repeat wait() until cloneCompleted
		checkProceduralPart(currentPart)
	end

	local nextMultiple = roomSize
	local RoomNumber = 1

	for i,v in pairs (RoomTable) do -->>: Adds the EndParts to the rooms
		if i % nextMultiple == 0 then
			local RoomFolder = Instance.new("Folder", workspace.TargetFilter.Map.DungeonRooms)
			RoomFolder.Name = "Room-"..tostring(RoomNumber)
			local partName = "End-"..tostring(RoomNumber)
			local newModel = Instance.new('Model', workspace.TargetFilter.Map.DungeonRooms)
			newModel.Name = partName
			for i,v in pairs (game.ServerStorage.DungeonParts.DungeonEnd:GetChildren()) do
				v:Clone().Parent = newModel
			end
			currentPart = newModel
			newModel.PrimaryPart = newModel:FindFirstChild("Floor")
			if string.sub(v.Name, 1, 5) == "Front" then -- works
				newModel:SetPrimaryPartCFrame(RoomTable[i]:GetPrimaryPartCFrame() * CFrame.new(0, 0, -movingCFrameVal))
			elseif string.sub(v.Name, 1, 10) == "LeftCorner" then -- works
				newModel:SetPrimaryPartCFrame(RoomTable[i]:GetPrimaryPartCFrame() * CFrame.new(0, 0, movingCFrameVal) * CFrame.fromEulerAnglesXYZ(0,math.rad(180),0))
			elseif string.sub(v.Name, 1, 11) == "RightCorner" then -- works
				newModel:SetPrimaryPartCFrame(RoomTable[i]:GetPrimaryPartCFrame() * CFrame.new(-movingCFrameVal, 0, 0) * CFrame.fromEulerAnglesXYZ(0,math.rad(90),0))
			end
			CollectionService:AddTag(newModel, "Obstacle")
			RoomNumber += 1
		end
	end
	
	local tempRoomNumber = 1
	
	for iRoom,v in pairs (RoomTable) do -->>: Puts rooms into correct folders
		v.Floor.Parent = workspace.FloorFilter
		if iRoom % nextMultiple == 0 then
			for i = (nextMultiple-1), 0, -1 do
				RoomTable[iRoom - i].Parent = workspace.TargetFilter.Map.DungeonRooms:FindFirstChild("Room-"..tostring(tempRoomNumber))
			end
			tempRoomNumber += 1
		end
	end

end

function DungeonGenerationService:KnitInit()
end

function DungeonGenerationService:KnitStart()
	-->>: When knit starts, automatically generates dungeon layout
	DungeonGenerationService:Generate(10, 3, 60, Vector3.new(90, -1, -240)) -->>: Number of Rooms, Room Chunks, Floor Size, Start CFrame
end

return DungeonGenerationService
